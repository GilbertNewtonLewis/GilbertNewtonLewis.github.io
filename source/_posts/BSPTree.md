---
title: 一个关于BSP的简单研究与实现
date: 2024-06-21 18:09:20
tags: 计算机图形学
---

<meta name="referrer" content="no-referrer"/>

# 1.前言

假如我们现在要设计一个视图场景(Scene)，在其中包含很多图元对象(Item)。就像这样:

![image-20240620173747423](https://img-blog.csdnimg.cn/direct/1fd6841c111a4978a1999dfdb0e43834.png)

<!-- more -->

上面就是一个场景，其中包含了大量的线条与色块等等，这些所有的图形要素都统称为"图元"。而场景就负责管理并绘制图元、接收并向对应的图元转发UI事件。我们现在假设场景是静态场景，也就是场景中的图元在初始化以后就不会有任何改变。

现在我们想让这个场景当中的图元响应用户的UI操作，比如说，用鼠标点击场景中的某个位置，场景就需要找到有哪根线条覆盖到了那个位置，然后让那个线条唱跳rap。虽然我们在实现这个逻辑的时候希望能有一个“点信息表”可以根据鼠标点下的位置直接检索出对应的点上有哪些图元覆盖到这样的相关信息，但场景保存的是“各个图元”相关的信息成一个“图元信息表”，而不太可能把“每个点”相关的信息保存成“点信息表”——如果想用“点”来衡量一整个视图场景的大小，那真是让人吐血，想想你那8K超清的大屏幕上算出来有多少个点吧，如果想要保存“每个点被哪些图元覆盖到”这样的信息，需要一个什么规模的二维数组(......)。所以我们知道用户的鼠标落在哪个“点”上之后，要做的是去“图元信息表”寻找“哪些图元覆盖了这个点”，毕竟，场景保存的是“各个图元”的“图元信息表”，不会丧心病狂到去把“每个点”的信息保存成一个“点信息表”。

你可能会说，这多简单，对图元信息表中的每个图元遍历一次，看看哪个图元覆盖了那个位置呗。我们一般管这种做法叫暴力搜索，当然这不是说它完全错误，一个方法只要能达到目的那它就不是绝对的错误；但是必须考虑的事情是，宇宙是有限的，连一个葛立恒数大小的物理概念在我们的宇宙中都找不到，那就不能在讨论一个事情的时候抛开它的时空限制、可用资源限制这些事实层面的东西不谈。比如说，现在场景当中有一千万个图元(不要惊讶，这种情况当然有可能出现，比如说卫星地图或者高品质游戏等一些高精绘图场景，或者你哪天想起来要给你未来的对象展示一下属于码农的浪漫于是把参数调成一千万:dog::dog:)，那用户每点一下就要暴力搜索数秒(也许经常使用天河一号的朋友们还不用担心在这个数量级下产生这个问题，但是我这个臭写代码的还是不能忘了那些使用PC的人们)，如果这景象出现在一个游戏里那它早已被市场淘汰:dog::dog:。但是前面我们又说过，“遍历图元”这样的操作逃不掉的，那么有什么能提高效率的方法呢？

计算机图形学对此问题早有研究，并提出了“空间数据结构”的概念。很多时候我们需要能够方便地在空间中定位和查找的数据结构来处理物体，这称为空间数据结构。空间数据结构大多通过将空间划分为多个层次多个区域来方便查找空间中的元素，被广泛用在图形学场景中用来加快运算。现在场景中有一千万个图元，原本在遍历的时候需要对这一千万个图元都遍历，但是现在有一种空间数据结构将整个场景不重不漏地划分成了1000个区域，那现在平均每个区域就只有一万个图元了，而用户点到的那个位置一定只落在某个区域当中(谁让它这么没出息只是一个点呢)，所以现在只需要遍历一万个左右的图元了。当然这只是一个比较理想化的模型，实际操作起来还会遇到其他的细节问题，比如说如果有很多图元它就是比你能划出来的区域更大该怎么办呢。而下文所要探讨的，就是标题中那个名叫BSP的空间数据结构以及实现时的各种细节问题。

# 2.BSP的概念

BSP(Binary Space Partitioning，空间二叉划分)是一种空间数据结构，它可以对一个二维或三维空间进行划分，下文探讨的是二维空间的情形。每次将空间划分为两个部分并对每个划分出的子空间递归重复这个过程，然后使用树结构将空间组合起来，最后得到的就是一棵二叉树，这棵二叉树的每个叶节点对应一块区域，每个非叶节点对应一次划分所用的分割线。这个道理其实很容易想到，因为在进行划分的过程中，所有非叶节点都经历了派生出子节点的过程，也就是说它们经历了“从叶节点变成了非叶节点”的过程，这个过程自然会让这个节点的角色发生改变：当一个节点还没有派生子节点时，它在这棵(尚未完成)的树上是一个叶节点，代表了一个区域；而当它派生出子节点后，它自己就变成了非叶节点，那么它现在就代表了一条分割线，其实很好理解，从一个原本的叶节点“派生子节点”对应的操作就是对原本节点代表的区域进行划分，在划分后这个节点就代表了分割线，而它派生的子节点现在就代表分出的两个子区域，当然，子节点也可以继续对自己进行上面这个操作。

一种简单且常见的BSP划分方式是“轴向划分”，它每次划分都简单地在每个子空间的对称轴上进行划分，对于矩形场景而言，对称轴就是每个子空间水平或垂直的中线轴，而且这样划分出的子空间同样是矩形，对这些子空间也依然从对称轴上进行划分。通常来说，轴向划分最终形成一棵满二叉树：所有非叶节点的度都是2，所有叶节点都在同一层次上，也就是说每一个同级的子区域都会进行划分，直到达到所要求的树深度。我们在划分区域时一般都采取“横竖交替”的策略(很好理解，有谁会一直竖着画呢？双缝干涉实验？)，如果一个节点是按照水平中线轴划分，那么它所派生的子节点再划分的时候就是按照垂直中线轴划分。

